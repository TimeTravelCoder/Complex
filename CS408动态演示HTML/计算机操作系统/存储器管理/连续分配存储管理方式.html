<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº¤äº’å¼å­¦ä¹ ç¬”è®°ï¼šè¿ç»­åˆ†é…å­˜å‚¨ç®¡ç†</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chosen Palette: Slate Gray & Blue (Background: #f1f5f9, Text: #334155, Accent: #3b82f6, Green: #22c55e, Red: #ef4444) -->
    <!-- Application Structure Plan: The SPA is designed as a learning journey. It starts with static concepts (Single/Fixed partitioning), then moves to the core interactive element: a dynamic memory allocation simulator. This simulator allows users to visually compare FF, BF, and WF algorithms, directly addressing the main learning objective. Following the simulation, the app explains the resulting problem (fragmentation) and the solution (compaction), reinforcing the concepts learned through interaction. This structureâ€”from simple to complex, from problem to solutionâ€”is designed for optimal pedagogical flow. -->
    <!-- Visualization & Content Choices: 
        - Memory Visualization: Goal: Inform/Compare. Method: HTML divs styled with Tailwind, dynamically rendered by JS to represent memory blocks. Interaction: The visualization updates in response to user actions in the simulator. Justification: Provides a concrete, visual representation of the abstract memory space, making allocation and fragmentation tangible.
        - Allocation Algorithm Simulator: Goal: Compare/Organize. Method: A control panel with algorithm selection and action buttons coupled with the memory visualization. Interaction: Users select an algorithm (FF, BF, WF) and click "Allocate" to see the chosen algorithm's decision-making process animated on the memory visualization. Justification: This is the core interactive element. It transforms passive reading about algorithms into an active, experimental learning process.
        - Fragmentation Explanation: Goal: Inform. Method: Side-by-side static diagrams using styled HTML divs. Interaction: None. Justification: Clearly and concisely differentiates internal vs. external fragmentation after the user has seen them occur in the simulator.
        - Compaction Animation: Goal: Inform. Method: A JS-driven animation on the memory visualization. Interaction: A "Compact Memory" button triggers the animation. Justification: Visually demonstrates the solution to external fragmentation, completing the learning loop.
        - Library/Method: Vanilla JS for all logic and animation. Chart.js for a simple chart showing memory utilization. NO SVG/Mermaid used. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f1f5f9; /* slate-100 */
        }
        .section-card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem 2rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            margin-bottom: 2rem;
        }
        .memory-container {
            border: 2px solid #e2e8f0; /* slate-200 */
            background: repeating-linear-gradient(45deg, #f8fafc, #f8fafc 10px, #f1f5f9 10px, #f1f5f9 20px);
            padding: 0.5rem;
            height: 500px;
        }
        .memory-block {
            position: absolute;
            width: 100%;
            border: 1px solid rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.5s ease-in-out;
            overflow: hidden;
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.05);
        }
        .block-os { background-color: #64748b; color: white; } /* slate-500 */
        .block-free { background-color: #f1f5f9; color: #475569; border-style: dashed; } /* slate-100, slate-600 */
        .block-proc { background-color: #3b82f6; color: white; } /* blue-500 */
        .highlight-scan { background-color: #fef08a; } /* yellow-200 */
        .highlight-select { background-color: #4ade80; } /* green-400 */
        
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body class="text-slate-700">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold text-slate-900">è¿ç»­åˆ†é…å­˜å‚¨ç®¡ç†æ–¹å¼</h1>
            <p class="mt-4 text-lg text-slate-600">é€šè¿‡äº¤äº’å¼æ¨¡æ‹Ÿï¼Œæ·±å…¥ç†è§£å†…å­˜çš„åˆ†é…ä¸å›æ”¶ã€‚</p>
        </header>

        <!-- Section 1: Intro to Continuous Allocation -->
        <section class="section-card">
            <h2 class="text-2xl font-bold mb-4">ä»€ä¹ˆæ˜¯è¿ç»­åˆ†é…ï¼Ÿ</h2>
            <p class="mb-4">è¿ç»­åˆ†é…æ˜¯æœ€æ—©æœŸçš„å†…å­˜ç®¡ç†æ–¹å¼ï¼Œå®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šå½“ä¸€ä¸ªç¨‹åºéœ€è¦è¿è¡Œæ—¶ï¼Œå¿…é¡»åœ¨å†…å­˜ä¸­ä¸ºå®ƒæ‰¾åˆ°ä¸€å—è¿ç»­çš„ã€è¶³å¤Ÿå¤§çš„ç©ºé—´ã€‚è¿™ç§æ–¹å¼ç®€å•ç›´è§‚ï¼Œä½†éšç€å¤šé“ç¨‹åºçš„å‘å±•ï¼Œå…¶å›ºæœ‰çš„ç¼ºé™·ä¹Ÿé€æ¸æš´éœ²å‡ºæ¥ï¼Œä¸»è¦å°±æ˜¯ç¢ç‰‡é—®é¢˜ã€‚</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="p-4 bg-slate-50 rounded-lg">
                    <h3 class="font-bold text-lg">å•ä¸€è¿ç»­åˆ†é…</h3>
                    <p class="text-sm">æœ€ç®€å•çš„æ¨¡å¼ï¼Œå†…å­˜åªåˆ†ä¸ºç³»ç»ŸåŒºå’Œç”¨æˆ·åŒºã€‚ç”¨æˆ·åŒºä»…å®¹çº³ä¸€ä¸ªç¨‹åºï¼Œåˆ©ç”¨ç‡æä½ã€‚</p>
                </div>
                <div class="p-4 bg-slate-50 rounded-lg">
                    <h3 class="font-bold text-lg">å›ºå®šåˆ†åŒºåˆ†é…</h3>
                    <p class="text-sm">é¢„å…ˆå°†å†…å­˜åˆ’åˆ†ä¸ºå¤šä¸ªå›ºå®šå¤§å°çš„åˆ†åŒºã€‚ä¼šäº§ç”Ÿ <b class="text-red-500">å†…éƒ¨ç¢ç‰‡</b>ï¼ˆåˆ†åŒºå†…æœªè¢«ä½¿ç”¨çš„ç©ºé—´ï¼‰ã€‚</p>
                </div>
            </div>
        </section>

        <!-- Section 2: Dynamic Allocation Simulator -->
        <section id="simulator" class="section-card">
            <h2 class="text-3xl font-bold mb-2">åŠ¨æ€åˆ†åŒºåˆ†é…æ¨¡æ‹Ÿå™¨</h2>
            <p class="text-slate-600 mb-6">è¿™æ˜¯æœ¬è®²çš„é‡ç‚¹ã€‚åŠ¨æ€åˆ†åŒºåˆ†é…ä¸é¢„è®¾åˆ†åŒºï¼Œè€Œæ˜¯æ ¹æ®è¿›ç¨‹å¤§å°åŠ¨æ€åˆ’åˆ†ã€‚è¯·é€‰æ‹©ä¸€ä¸ªåˆ†é…ç®—æ³•ï¼Œç„¶åç‚¹å‡»â€œåˆ†é…ä¸‹ä¸€ä¸ªè¿›ç¨‹â€æ¥è§‚å¯Ÿå®ƒçš„å·¥ä½œæµç¨‹å’Œç»“æœã€‚æ‚¨è¿˜å¯ä»¥é€šè¿‡ç‚¹å‡»è¿›ç¨‹å—å³ä¸Šè§’çš„ "Ã—" æ¥é‡Šæ”¾å®ƒã€‚</p>
            
            <div class="grid lg:grid-cols-3 gap-8">
                <!-- Memory Visualization -->
                <div class="lg:col-span-1">
                    <h3 class="font-bold text-lg text-center mb-2">å†…å­˜è§†å›¾ (å…± 640 KB)</h3>
                    <div id="memory-viz" class="memory-container relative w-full rounded-lg">
                        <!-- Memory blocks will be rendered here by JS -->
                    </div>
                </div>

                <!-- Controls and Info -->
                <div class="lg:col-span-2">
                    <div class="grid md:grid-cols-2 gap-6">
                        <!-- Controls -->
                        <div>
                            <h3 class="font-bold text-lg mb-2">æ§åˆ¶é¢æ¿</h3>
                            <div class="space-y-4">
                                <div>
                                    <label for="alloc-algo" class="font-semibold text-slate-700">1. é€‰æ‹©åˆ†é…ç®—æ³•:</label>
                                    <select id="alloc-algo" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                        <option value="ff">é¦–æ¬¡é€‚åº” (First Fit)</option>
                                        <option value="bf">æœ€ä½³é€‚åº” (Best Fit)</option>
                                        <option value="wf">æœ€åé€‚åº” (Worst Fit)</option>
                                    </select>
                                </div>
                                <button id="alloc-btn" class="w-full bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition">åˆ†é…ä¸‹ä¸€ä¸ªè¿›ç¨‹</button>
                                <button id="compact-btn" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 transition" disabled>æ‰§è¡Œå†…å­˜ç´§å‡‘</button>
                                <button id="reset-btn" class="w-full bg-slate-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-slate-600 transition">é‡ç½®æ¨¡æ‹Ÿ</button>
                            </div>
                        </div>
                        <!-- Process Queue -->
                        <div>
                           <h3 class="font-bold text-lg mb-2">è¿›ç¨‹è¯·æ±‚é˜Ÿåˆ—</h3>
                            <ul id="process-queue" class="space-y-2">
                                <!-- Process queue items will be rendered here by JS -->
                            </ul>
                        </div>
                    </div>
                    <!-- Log -->
                    <div class="mt-6">
                        <h3 class="font-bold text-lg mb-2">æ“ä½œæ—¥å¿—</h3>
                        <div id="log-area" class="h-40 bg-slate-800 text-white font-mono text-sm p-4 rounded-lg overflow-y-auto">
                            <p>> æ¨¡æ‹Ÿå™¨å·²å°±ç»ª...</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Fragmentation & Compaction -->
        <section class="section-card">
            <h2 class="text-2xl font-bold mb-4">æ ¸å¿ƒé—®é¢˜ï¼šç¢ç‰‡ (Fragmentation)</h2>
            <p class="mb-6">åœ¨æ¨¡æ‹Ÿä¸­æ‚¨å¯èƒ½å·²ç»æ³¨æ„åˆ°ï¼Œéšç€è¿›ç¨‹çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œå†…å­˜ä¸­ä¼šäº§ç”Ÿè®¸å¤šæ— æ³•åˆ©ç”¨çš„å°ç©ºé—²å—ï¼Œè¿™å°±æ˜¯ç¢ç‰‡é—®é¢˜ï¼Œå®ƒæ˜¯è¿ç»­åˆ†é…æ–¹å¼çš„ä¸»è¦å¼Šç«¯ã€‚</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div class="p-4 bg-slate-50 rounded-lg">
                    <h3 class="font-bold text-lg text-red-600">ğŸ”´ å¤–éƒ¨ç¢ç‰‡ (External Fragmentation)</h3>
                    <p class="text-sm mt-2">æŒ‡åœ¨æ‰€æœ‰å·²åˆ†é…åŒºåŸŸä¹‹é—´å­˜åœ¨çš„ã€ä¸è¿ç»­çš„ç©ºé—²åˆ†åŒºã€‚è™½ç„¶ç©ºé—²ç©ºé—´çš„æ€»å’Œå¯èƒ½å¾ˆå¤§ï¼Œä½†ç”±äºå®ƒä»¬ä¸è¿ç»­ï¼Œæ— æ³•æ»¡è¶³éœ€è¦è¾ƒå¤§è¿ç»­ç©ºé—´çš„æ–°è¿›ç¨‹ã€‚è¿™æ˜¯åŠ¨æ€åˆ†åŒºåˆ†é…çš„ä¸»è¦é—®é¢˜ã€‚</p>
                </div>
                <div class="p-4 bg-slate-50 rounded-lg">
                    <h3 class="font-bold text-lg text-orange-500">ğŸŸ  å†…éƒ¨ç¢ç‰‡ (Internal Fragmentation)</h3>
                    <p class="text-sm mt-2">æŒ‡åœ¨ä¸€ä¸ªå·²åˆ†é…çš„åˆ†åŒºå†…éƒ¨ï¼Œç¨‹åºæœªä½¿ç”¨è€Œæµªè´¹æ‰çš„ç©ºé—´ã€‚ä¾‹å¦‚ï¼Œä¸º 33KB çš„è¿›ç¨‹åˆ†é…äº† 64KB çš„ä¼™ä¼´ç³»ç»Ÿå—ã€‚è¿™æ˜¯å›ºå®šåˆ†åŒºå’Œä¼™ä¼´ç³»ç»Ÿç­‰æ–¹å¼çš„ä¸»è¦é—®é¢˜ã€‚</p>
                </div>
            </div>
             <div class="mt-8 text-center">
                <h3 class="text-xl font-bold mb-2">è§£å†³æ–¹æ¡ˆï¼šç´§å‡‘ (Compaction)</h3>
                <p>è§£å†³å¤–éƒ¨ç¢ç‰‡çš„ä¸€ç§æ–¹æ³•æ˜¯å†…å­˜ç´§å‡‘ã€‚é€šè¿‡ç§»åŠ¨å†…å­˜ä¸­çš„æ‰€æœ‰è¿›ç¨‹ï¼Œä½¿å®ƒä»¬è¿ç»­æ’åˆ—ï¼Œä»è€Œå°†æ‰€æœ‰å°çš„ç©ºé—²åˆ†åŒºåˆå¹¶æˆä¸€ä¸ªå¤§çš„è¿ç»­ç©ºé—²åŒºã€‚è¯·åœ¨æ¨¡æ‹Ÿå™¨ä¸­å°è¯•â€œæ‰§è¡Œå†…å­˜ç´§å‡‘â€æŒ‰é’®æ¥è§‚å¯Ÿè¿™ä¸ªè¿‡ç¨‹ã€‚è¯¥æ“ä½œéœ€è¦åŠ¨æ€é‡å®šä½ç¡¬ä»¶çš„æ”¯æŒã€‚</p>
            </div>
        </section>

    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const VIZ_HEIGHT = 500;
    const TOTAL_MEMORY = 640; // KB

    const memoryViz = document.getElementById('memory-viz');
    const processQueueEl = document.getElementById('process-queue');
    const logArea = document.getElementById('log-area');
    const allocBtn = document.getElementById('alloc-btn');
    const compactBtn = document.getElementById('compact-btn');
    const resetBtn = document.getElementById('reset-btn');
    const algoSelect = document.getElementById('alloc-algo');

    let memoryState = [];
    let processQueue = [];
    let nextProcId = 1;

    const initialProcesses = [
        { id: 'P1', size: 130 },
        { id: 'P2', size: 60 },
        { id: 'P3', size: 100 },
        { id: 'P4', size: 200 },
        { id: 'P5', size: 140 },
        { id: 'P6', size: 70 },
        { id: 'P7', size: 120 },
    ];
    
    function init() {
        memoryState = [
            { start: 0, size: 40, type: 'os' },
            { start: 40, size: 600, type: 'free' }
        ];
        processQueue = JSON.parse(JSON.stringify(initialProcesses));
        
        allocBtn.disabled = false;
        compactBtn.disabled = true;
        
        renderMemory();
        renderQueue();
        log('æ¨¡æ‹Ÿå™¨å·²é‡ç½®ã€‚');
    }

    function log(message) {
        logArea.innerHTML += `<p>> ${message}</p>`;
        logArea.scrollTop = logArea.scrollHeight;
    }

    function renderMemory() {
        memoryViz.innerHTML = '';
        let freeBlocks = memoryState.filter(b => b.type === 'free');

        memoryState.forEach(block => {
            const blockEl = document.createElement('div');
            blockEl.className = `memory-block block-${block.type}`;
            blockEl.style.top = `${(block.start / TOTAL_MEMORY) * VIZ_HEIGHT}px`;
            blockEl.style.height = `${(block.size / TOTAL_MEMORY) * VIZ_HEIGHT}px`;
            
            let text = '';
            if (block.type === 'os') {
                text = 'æ“ä½œç³»ç»Ÿ';
            } else if (block.type === 'proc') {
                text = `è¿›ç¨‹ ${block.id} (${block.size}KB)`;
                const freeBtn = document.createElement('button');
                freeBtn.className = 'absolute top-1 right-1 text-white opacity-60 hover:opacity-100 font-bold text-lg leading-none p-1';
                freeBtn.innerHTML = '&times;';
                freeBtn.title = `é‡Šæ”¾è¿›ç¨‹ ${block.id}`;
                freeBtn.onclick = (e) => {
                    e.stopPropagation();
                    freeProcess(block.id);
                };
                blockEl.appendChild(freeBtn);
            } else {
                text = `ç©ºé—² (${block.size}KB)`;
            }
            
            const textEl = document.createElement('span');
            textEl.textContent = text;
            blockEl.appendChild(textEl);
            blockEl.dataset.start = block.start;
            memoryViz.appendChild(blockEl);
        });
        
        compactBtn.disabled = freeBlocks.length <= 1;
    }

    function renderQueue() {
        processQueueEl.innerHTML = '';
        processQueue.forEach((proc, index) => {
            const li = document.createElement('li');
            li.className = `p-2 rounded-md flex justify-between items-center ${index === 0 ? 'bg-blue-100' : 'bg-slate-100'}`;
            li.innerHTML = `<span>è¿›ç¨‹ ${proc.id}</span><span class="font-bold">${proc.size}KB</span>`;
            processQueueEl.appendChild(li);
        });
        if(processQueue.length === 0) {
            processQueueEl.innerHTML = '<li class="p-2 text-slate-500">æ‰€æœ‰è¿›ç¨‹å·²åˆ†é…æˆ–åœ¨é˜Ÿåˆ—ä¸­ã€‚</li>';
            allocBtn.disabled = true;
        } else {
            allocBtn.disabled = false;
        }
    }
    
    function freeProcess(id) {
        log(`è¯·æ±‚é‡Šæ”¾è¿›ç¨‹ ${id}...`);
        let blockIndex = -1;
        for (let i = 0; i < memoryState.length; i++) {
            if (memoryState[i].type === 'proc' && memoryState[i].id === id) {
                blockIndex = i;
                break;
            }
        }

        if (blockIndex === -1) return;

        memoryState[blockIndex].type = 'free';
        delete memoryState[blockIndex].id;

        // Merge with next block if it's free
        if (blockIndex + 1 < memoryState.length && memoryState[blockIndex + 1].type === 'free') {
            const nextBlock = memoryState[blockIndex + 1];
            memoryState[blockIndex].size += nextBlock.size;
            memoryState.splice(blockIndex + 1, 1);
            log(`ä¸åä¸€ä¸ªç©ºé—²å—åˆå¹¶ã€‚`);
        }

        // Merge with previous block if it's free
        if (blockIndex > 0 && memoryState[blockIndex - 1].type === 'free') {
            const prevBlock = memoryState[blockIndex - 1];
            memoryState[blockIndex].start = prevBlock.start;
            memoryState[blockIndex].size += prevBlock.size;
            memoryState.splice(blockIndex - 1, 1);
            log(`ä¸å‰ä¸€ä¸ªç©ºé—²å—åˆå¹¶ã€‚`);
        }
        
        const freedProcessInfo = initialProcesses.find(p => p.id === id);
        if (freedProcessInfo && !processQueue.find(p => p.id === id)) {
            processQueue.push(freedProcessInfo);
            processQueue.sort((a, b) => a.id.localeCompare(b.id, undefined, {numeric: true}));
        }

        log(`è¿›ç¨‹ ${id} å·²é‡Šæ”¾ã€‚`);
        renderMemory();
        renderQueue();
    }


    async function allocate() {
        if (processQueue.length === 0) {
            log('é˜Ÿåˆ—ä¸­å·²æ— è¿›ç¨‹ã€‚');
            return;
        }

        allocBtn.disabled = true;
        const process = processQueue[0];
        log(`è¯·æ±‚ä¸ºè¿›ç¨‹ ${process.id} åˆ†é… ${process.size}KB...`);

        const algo = algoSelect.value;
        let bestFitIndex = -1;

        const freeBlocks = memoryState.map((b, i) => ({ ...b, originalIndex: i }))
            .filter(b => b.type === 'free' && b.size >= process.size);

        if (freeBlocks.length === 0) {
            log(`<span class="text-red-400">é”™è¯¯: æ²¡æœ‰è¶³å¤Ÿå¤§çš„è¿ç»­ç©ºé—²åˆ†åŒºã€‚</span>`);
            allocBtn.disabled = false;
            return;
        }
        
        await sleep(500);

        if (algo === 'ff') {
            log('ä½¿ç”¨é¦–æ¬¡é€‚åº”(FF)ç®—æ³•...');
            let foundBlock = freeBlocks[0];
            for(const block of freeBlocks) {
                await highlightBlock(block.start, 'scan');
            }
            bestFitIndex = foundBlock.originalIndex;
        } else if (algo === 'bf') {
            log('ä½¿ç”¨æœ€ä½³é€‚åº”(BF)ç®—æ³•...');
            let bestBlock = freeBlocks.reduce((min, block) => block.size < min.size ? block : min, freeBlocks[0]);
            for(const block of freeBlocks) {
                await highlightBlock(block.start, 'scan');
            }
            bestFitIndex = bestBlock.originalIndex;
        } else if (algo === 'wf') {
            log('ä½¿ç”¨æœ€åé€‚åº”(WF)ç®—æ³•...');
            let bestBlock = freeBlocks.reduce((max, block) => block.size > max.size ? block : max, freeBlocks[0]);
            for(const block of freeBlocks) {
                await highlightBlock(block.start, 'scan');
            }
            bestFitIndex = bestBlock.originalIndex;
        }

        await sleep(500);
        await highlightBlock(memoryState[bestFitIndex].start, 'select');
        log(`é€‰ä¸­åˆ†åŒº: èµ·å§‹äº ${memoryState[bestFitIndex].start}K, å¤§å° ${memoryState[bestFitIndex].size}KBã€‚`);
        
        const originalBlock = memoryState[bestFitIndex];
        const newProcBlock = {
            start: originalBlock.start,
            size: process.size,
            type: 'proc',
            id: process.id,
        };

        const remainingSize = originalBlock.size - process.size;
        
        processQueue.shift();
        
        if (remainingSize > 5) { // Avoid creating tiny fragments
            const remainingFreeBlock = {
                start: originalBlock.start + process.size,
                size: remainingSize,
                type: 'free'
            };
            memoryState.splice(bestFitIndex, 1, newProcBlock, remainingFreeBlock);
        } else {
            newProcBlock.size = originalBlock.size; // Allocate the whole block
            memoryState.splice(bestFitIndex, 1, newProcBlock);
        }

        memoryState.sort((a,b) => a.start - b.start);
        
        await sleep(1000);
        log(`è¿›ç¨‹ ${process.id} åˆ†é…æˆåŠŸã€‚`);
        renderMemory();
        renderQueue();
    }
    
    async function compact() {
        log('å¼€å§‹æ‰§è¡Œå†…å­˜ç´§å‡‘...');
        compactBtn.disabled = true;
        allocBtn.disabled = true;
        
        let freeSizeTotal = 0;
        let tempState = [];
        let currentPos = 0;
        
        memoryState.forEach(b => {
            if (b.type === 'os' || b.type === 'proc') {
                tempState.push({...b, newStart: currentPos});
                currentPos += b.size;
            } else {
                freeSizeTotal += b.size;
            }
        });

        for(const block of tempState) {
             const el = document.querySelector(`.memory-block[data-start="${block.start}"]`);
             if (el) {
                 el.style.top = `${(block.newStart / TOTAL_MEMORY) * VIZ_HEIGHT}px`;
             }
        }
        
        await sleep(1000);

        memoryState = tempState.map(b => ({start: b.newStart, size: b.size, type: b.type, id: b.id}));
        
        if (freeSizeTotal > 0) {
             memoryState.push({start: currentPos, size: freeSizeTotal, type: 'free'});
        }
        
        memoryState.sort((a, b) => a.start - b.start);

        renderMemory();
        log('å†…å­˜ç´§å‡‘å®Œæˆï¼');
        allocBtn.disabled = processQueue.length === 0;
    }
    
    async function highlightBlock(start, type) {
        const el = document.querySelector(`.memory-block[data-start="${start}"]`);
        if (el) {
            el.classList.add(`highlight-${type}`);
            await sleep(300);
            el.classList.remove(`highlight-${type}`);
        }
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    allocBtn.addEventListener('click', allocate);
    resetBtn.addEventListener('click', init);
    compactBtn.addEventListener('click', compact);

    init();
});
</script>

</body>
</html>
